---
title: PEML Exercise Data Model
---
<section>
  <h2 id="intro">Data Model Schema for PEML Exercises</h2>
  <p>
    This page presents the data model for PEML. While PEML is its own notation,
    the data model's structure is also described in the form of a
    <a href="http://json-schema.org/">JSON Schema</a> for PEML:
  </p>
  <p><a href="PEML.json">http://cssplice.github.io/peml/schemas/PEML.json</a></p>
  <p>
    Even though PEML uses its own notation, the data model's structure can
    easily be mapped into JSON or YAML, and a JSON Schema provides a
    program-checkable way of expressing the intended data model structure.
    Snippets from the schema are included below to show the definitions
    for each key/value field in PEML. PEML fields that have their own
    substructure are described separately as building blocks in the
    <a href="definitions.html">definitions of recurring model elements</a>.
  </p>
  <p>
    The main attributes of a PEML exercise description are broken down into
    three groups: 
  </p>

  <p><b>Required keys</b></p>
  <ul>
    <li><a href="#exercise_id">exercise_id</a></li>
    <li><a href="#title">title</a></li>
    <li><a href="#author">author</a> (or <code>authors</code>) (at least one
      of <code>author</code> or <code>authors</code> or
      <code>license.owner</code> is required)</li>
  </ul>

  <p><b>Recommended keys</b></p>
  <ul>
    <li><a href="#instructions">instructions</a>
      (at least one of <code>instructions</code> or <code>suites</code>
      or <code>systems</code> is required)
    </li>
    <li><a href="#systems">systems</a></li>
    <li><a href="#version">version</a>
      <ul>
        <li><a href="#version.timestamp">version.timestamp</a></li>
        <li><a href="#version.type">version.type</a></li>
        <li><a href="#version.id">version.id</a></li>
        <li><a href="#version.timestamp">version.timestamp</a></li>
        <li><a href="#version.repository">version.repository</a></li>
      </ul></li>
    <li><a href="#license">license</a>
      <ul>
        <li><a href="#license.id">license.id</a></li>
        <li><a href="#license.owner">license.owner</a></li>
        <li><a href="#license.book">license.book</a></li>
        <li><a href="#license.attribution">license.attribution</a></li>
        <li><a href="#license.acknowledgements">license.acknowledgements</a></li>
        <li><a href="#license.permissions">license.permissions</a></li>
      </ul></li>
  </ul>

  <p><b>Optional keys</b></p>
  <ul>
    <li><a href="#tag">tag</a></li>
    <li><a href="#src">src</a></li>
    <li><a href="#suites">suites</a></li>
    <li><a href="#difficulty">difficulty</a></li>
    <li><a href="#vendor">vendor</a></li>
  </ul>

  <p><b>Keys under development</b></p>
  <ul>
    <li><a href="#options">options</a></li>
    <li><a href="#origin">origin</a></li>
  </ul>

  <p>It is important to note that PEML allows the use of additional keys
    beyond those described here, which may be custom-supported by specific
    tools. THe list of keys described here is intended to provide a
    <b>common vocabulary</b> that can be used by many tools for
    <b>representing</b> programming exercises, to facilitate <b>authoring</b>,
    <b>importing</b>, and <b>exporting</b> these exercises. Some
    keys may relate to features or content that is not supported in every
    tool, but the goal is to streamline the ability of instructors (or "people"
    in general) to get exercises into (and potentially out of) educational
    tools.
  </p>
</section>

<section>
  <h2 id="required">Required Keys</h2>
  <p>
    <strong>Required</strong> keys must be present in each PEML description.
    We keep these to a minimum. However, to promote some aspects of
    interoperability and data management, considering these required elements
    on every exercise will help authors keep information organized when it
    is imported into tools.
  </p>

  <section>
    <h3 id="exercise_id" data-toc-title="exercise_id">exercise_id
      <small class="text-muted">required: string</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"exercise_id": { "type": "string", "minLength": 1, "pattern": "^[^\s]+$" }
{% endhighlight %}

    <p>
      The <code>exercise_id</code> is a globally unique, human-written
      identifier created by the exercise
      author to uniquely identify this exercise on any system. Any non-empty
      sequence of non-whitespace unicode characters can be used. We imagine
      that authors might construct these identifiers in similar ways to
      programming package names or URLs. For example, the following ID includes
      a university and course identifier around an exercise name that is
      presumed to be unique within that context. By combining the context
      and the name, a globally unique identifier can be formed: 
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
exercise_id: edu.vt.cs.cs1114.palindromes
{% endhighlight %}
    <p>
      By convention, exercises should start with the <code>exercise_id</code>
      key first, so that multiple exercises can be concatenated together in a
      single file but still sliced/parsed as separate exercises easily.
    </p>
    <p>
      The purpose of the <code>exercise_id</code> is to serve as an external
      identifier that tools (and people) can use to determine whether two
      PEML descriptions describe "the same thing". Exercises with different
      ids should be considered as distinct entities, rather than as different
      versions of the "same thing". The <code>version</code> key is used to
      identify basic version info for long-lived exercises.
    </p>
    <p>
      When a user externally edits an exercise representation and re-imports
      it into a tool, or exports an exercise from one tool to use in another
      context, tools can use the <code>exercise_id</code> to determine whether
      imported information is an update to an existing artifact or whether it
      defines a new exercise.
    </p>
  </section>


  <section>
    <h3 id="title" data-toc-text="title">title
      <small class="text-muted">required: string</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"title": { "type": "string", "minLength": 1 }
{% endhighlight %}

    <p>
      The <code>title</code> is a string name or title used as a human-readable
      label for the
      exercise. The intent is for this to be the "title" shown to students
      in various contexts, either when viewing a single exercise or when
      viewing lists of exercises.  While there is no specific length limit,
      ideally titles should be no more than "one line" in size, because of
      the various contexts where they might be displayed. How much of the
      title is displayed (or truncated) when collections of exercises are
      shown is tool-dependent.
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
title: Palindromes (A Simple PEML Example)
{% endhighlight %}
  </section>

  <section>
    <h3 id="author" data-toc-text="author">author
      <small class="text-muted">required: string or object</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"author": {
  "oneOf": [
    { "$ref": "#/definitions/email_address" },
    {
      "type": "object",
      "required": ["email"],
      "properties": {
        "email": { "$ref": "#/definitions/email_address" },
        "name": { "$ref": "#/definitions/nonempty_string" }
      }
  ]
}
{% endhighlight %}

    <p>
      The <code>author</code> tag is used to identify the author of the
      exercise (or at least of the PEML exercise description). Recommended
      practice is to identify the author by a unique e-mail address. This
      field can be used to provide a single e-mail address. Alternatively,
      the key <code>authors</code> can be used to provide an array of
      multiple authors.
    </p>
    <p>
      If the optional <code>license</code> key is provided and the
      <code>license.owner</code> is the same as the <code>author</code>, then
      the <code>author</code> key can be omitted.
    </p>
    <p>In addition to providing an email address, the <code>author</code>
    tag can use sub-keys to specify both an email address and an author
    name.</p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
author: edwards@cs.vt.edu
{% endhighlight %}
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
# Providing name and email (email is always required)
author.name: Stephen Edwards
author.email: edwards@cs.vt.edu
{% endhighlight %}
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
# Multiple authors, specifying email only:
[authors]
* edwards@cs.vt.edu
* ayaan@vt.edu
[]

# Multiple authors with names:
[authors]
name: Stephen Edwards
email: edwards@cs.vt.edu
name: Ayaan Kazerouni
email: ayaan@vt.edu
[]
{% endhighlight %}
  </section>
</section>


<section>
  <h2 id="recommended">Recommended Keys</h2>

  <section>
    <h3 id="instructions" data-toc-text="instructions">instructions
      <small class="text-muted">recommended: string</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"instructions": { "type": "string" }
{% endhighlight %}

    <p>
      The <code>instructions</code> is where you can provide the exercise's
      instructions for the student describing the task to complete. This
      is the meat of the "assignment" or "exercise" in many cases. The value
      associated with this key is a string, but probably a long one. As with
      any key/value pairs in PEML, <a href="../index.html#quoting">quoting can
      be used</a>. Instructions <a href="../index.html#embedding-markup">written
      in Markdown</a> (or, as a subset, vanilla HTML) are useful, and some
      tools <a href="../index.html#embedding-markup">may support other
      markup formats</a>.
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
instructions:----------
Write your full assignment instructions here. Inline text instead of
a separate PDF resource is preferred.
...
----------
{% endhighlight %}
    <p>
      Note that some educational tools that support PEML may not use the
      instructions, or may expect that the instructions are provided through
      some means external to the tool. In these cases, the
      <code>instructions</code> field can be omitted, although in practice
      either <code>instructions</code> (describing the assignment) or
      <code>suites</code> (describing how a solution would be tested,
      either as a top-level key or nested inside one of the
      <code>systems</code> supported) are required.
    </p>
    <p>
      If in a specific situation the exercise's instructions are intended to
      be accessible through a course management system, an instructor-provided
      website, or some other mechanism, a URL can be used:
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
instructions: url(https://canvas.myschool.edu/courses/12345/assignments/12345)
{% endhighlight %}
    <p>
      While assignments can be farmed out into external files or web pages
      in this way,
      we strongly discourage the use of PDF assignment descriptions as
      limiting the value/utility of a PEML resource. However, in many
      cases that may be the fastest/cleanest way for an author to get started,
      and who then may move more into embedding markup in PEML descriptions
      on future assignments as time permits.
    </p>
  </section>

  <section>
    <h3 id="systems" data-toc-text="systems">systems
      <small class="text-muted">recommended: object</small></h3>

    <p>
      The <code>systems</code> key maps to an array of nested dictionaries
      (objects) that
      describe the programming language(s) or system(s) in which the exercise
      can be conducted. The full
      definition of what is included under <code>systems</code> is described
      in the <a href="code.html">code data model</a>.
    </p>
  </section>

  <section>
    <h3 id="version" data-toc-text="version">version
      <small class="text-muted">recommended: object</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"version": { "type": "object" }
{% endhighlight %}
    <p>
      Just as in YAML or JSON, a PEML description represents a set of key/value
      pairs (a dictionary, hash, or map, also called an "object" in JSON terms),
      where keys can map to nested structured values. In PEML, dotted names
      represent nesting structure.
      The <code>version</code> key maps to a nested dictionary (object) that
      identifies the version of this exercise that is described.
      Many authors may use forms of
      version control to manage their sources (which is recommended), so
      fields under <code>version</code> can be provided to
      capture access paths to an exercise description's version history.
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.timestamp: 2018-08-25T15:23:22.635-05:00
version.type: git
version.id: 2ab880a
version.repository.url: url(https://github.com/CSSPLICE/peml.git)
version.repository.path: url(test/peml/palindrome.peml)
{% endhighlight %}
    <p>
      Some tools may be able to deduce the type, repository, id, and location
      all from a single URL, such as with direct URLs to files on github.com.
      In such a situation, only the full location URL needs to be specified:
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.timestamp: 2018-08-25T15:23:22.635-05:00
version.repository: url(https://github.com/CSSPLICE/peml/blob/master/test/peml/palindrome.peml)
{% endhighlight %}

    <div class="container-fluid"><div class="row">
      <div class="bracket col-1"></div>
      <div class="col-11">

        <section>
          <h4 id="version.type" data-toc-text="version.type">version.type
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"id": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>version.type</code> captures the kind of version control
            system or repository format used for this PEML description's
            version history. Examples include: git, mercurial, CVS, Visual
            SourceSafe, etc.
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.type: git
{% endhighlight %}
        </section>

        <section>
          <h4 id="version.id" data-toc-text="version.id">version.id
            <small class="text-muted">optional: string</small></h3>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"type": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>version.id</code> is intended as a way to identify the
            commit within the repository holding this description's contents.
            It could be a tag, a branch name, a version number, a commit hash,
            etc. It's exact meaning is dependent on the nature of the version
            control system being used.
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.id: 2ab880a
{% endhighlight %}
        </section>

  <section>
    <h3 id="version.timestamp" data-toc-text="version.timestamp">version.timestamp
      <small class="text-muted">recommended: string</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"timestamp": {
  "type": "string",
  "minLength": 1,
  "pattern": "^(?:[1-9]\\d{3}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1\\d|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[1-9]\\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)-02-29)T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d{1,9})?(?:Z|[+-][01]\\d:[0-5]\\d)$",
}
{% endhighlight %}

    <p>
      The <code>version.timestamp</code>
      is a human-readable timestamp indicating the time at which this version
      of the exercise was last modified. For lack of a better option, at
      the moment this should be an RFC 3339/ISO 8601 UTC timestamp (if you
      know of something more user-friendly but equally unambiguous, let
      us know!). That format is: YYYY-MM-DDThh:mm:ss.nnnÂ±hh:mm.
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.timestamp: 2018-08-25T15:23:22.635-05:00
{% endhighlight %}
    <p>
      We expect that tool-edited exercise descriptions will likely generate
      this field's contents automatically. Also, tools will no doubt have to
      cope with the fact that authors who externally edit PEML representations
      might make multiple edits and re-import an exercise multiple times,
      while "forgetting" to manually update the timestamp. The point of the
      timestamp is to help authors (and tools) to distinguish between multiple
      edits/versions of a single exercise (with one <code>exercise_id</code>).
      However, tool developers are encouraged to keep hash fingerprints of
      exercise descriptions internally so that when externally edited/modified
      PEML descriptions are re-uploaded, they can (a) detect meaningful content
      changes, (b) use <code>version.timestamp</code> values to determine
      whether an import is a "newer" revision and inform users if the internally
      stored version is newer than what is being imported, and (c) in the
      case of <code>version.timestamp</code> "ties", prompt the author/user
      for more information (for example, suspecting failure to update the
      timestamp in a changed PEML description for an exercise that has already
      been imported).
    </p>
  </section>

        <section>
          <h4 id="version.repository">version.repository
            <small class="text-muted">optional: object</small></h4>

          <p>
            The <code>version.repository</code> is is a string or object
            intended to provide an
            access path to the repository containing this PEML description's
            version history. This is most likely a URL (see the discussion of
            URLs in
            <a href="../about.html#design">Design Goals</a>), although
            relative URLs that are resolved relative to the location of this
            PEML description can be used.
          </p>
          <p>
            Repositories are a recurring structure that can appear in multiple
            places in a PEML description. For details of how a repository
            can be described, see the
            <a href="definitions.html#repository">common repository substructure
            definition</a>.
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
version.repository: url(https://github.com/CSSPLICE/peml.git)
{% endhighlight %}
        </section>

      </div>
    </div></div>

  </section>

  <section>
    <h3 id="license" data-toc-text="license">license
      <small class="text-muted">recommended: object</small></h3>

    <p>
      The <code>license</code> key maps to a nested dictionary (object) that
      identifies the license that applies to use of the exercise. At a minimum,
      the <code>license</code> should include an
      <a href="#license.id">id</a> identifying which license governs use
      of the exercise. Additional information can be provided in the other
      optional fields if desired.
    </p>
    <p>
      If the <code>license</code> is provided, both the <code>license.id</code>
      and the <code>license.owner</code> are <strong>required</strong>.
    </p>

    
    <div class="container-fluid"><div class="row">
      <div class="bracket col-1"></div>
      <div class="col-11">

        <section>
          <h4 id="license.id">license.id
            <small class="text-muted">required: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"id": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>license.id</code> identifies the license used for this
            exercise. The id can be specified by a URL that identifies the
            license, or by a name (or abbreviated name) that is in common
            use, such as any of the
            <a href="https://help.github.com/en/articles/licensing-a-repository">license
            keywords used by github</a> (an excellent source for potential
            license choices).
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
license.id: cc-sa-4.0
{% endhighlight %}
        </section>
        <section>
          <h4 id="license.owner">license.owner
            <small class="text-muted">required: string or object</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"owner": {
  "anyOf": [
    { "$ref": "#person" },
     { "$ref": "#nonempty_string" }
  ]}
{% endhighlight %}
          <p>
            The <code>license.owner</code> identifies the person who "owns"
            the exercise being described, in the sense of intellectual
            property. This could be an individual, a publisher, a corporation,
            or whoever. For individual authors, unique e-mail addresses are
            preferred as a method of identification, although any string that
            unambiguously identifies the copyright holder/licenser for this
            work can be used here. A separate "email" sub-key and optional
            "name" sub-key can be provided, as in the <code>author</code> tag.
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
# simple form
license.owner: edwards@cs.vt.edu

# or provide email and name 
license.owner.email: edwards@cs.vt.edu
license.owner.name: Stephen Edwards
{% endhighlight %}
        </section>
        <section>
          <h4 id="license.book">license.book
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"book": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            In a situation where an exercise is part of a textbook or another
            copyrighted resource, the <code>license.book</code> key can
            be used to identify the source. In such cases, the "license" for
            use of the exercise is presumably the same as the license for
            the corresponding book or containing work. For most textbooks,
            reuse of resources from the book presumably requires owning a
            copy of the book. Such exercises should normally be limited to
            use in situations where the textbook is required or optional for
            a given pool of users (e.g., students in a course that use that
            textbook). The value of the <code>license.book</code> can either
            be a bibliographic-style citation for the book, or a URL
            that identifies the book.
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
license.book:
Cay S. Hortsmann, _Big Java: Early Objects, 5th Edition_,
Wiley, 2013. ISBN: 9788126554010
{% endhighlight %}
          <p>
            Tool developers are expected to be flexible and forgiving in terms
            of allowing for a wide variety of human-authored variations in
            specifying books, although tools should be free to "normalize"
            these to a standard representation internally (and even for
            presentation).
          </p>
        </section>
        <section>
          <h4 id="license.attribution">license.attribution
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"attribution": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>license.attribution</code>, if provided, contains an
            acknowledgement string that the license owner wishes for users
            of the exercise to include when using the work. The
            <code>license.attribution</code> should be provided for licenses
            that require users to provide attribution (such as Creative
            Commons licenses that include the "BY" requirement, or other
            licenses that require attribution).
          </p>
          <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
license.attribution:
"Palindromes (A Simple PEML Example)" by edwards@cs.vt.edu is licensed
under &lt;a href="https://creativecommons.org/licenses/by/4.0/"&gt;CC BY 4.0&lt;/a&gt;
{% endhighlight %}
        </section>
        <section>
          <h4 id="license.acknowledgements">license.acknowledgements
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"acknowledgements": { "type": "string" }
{% endhighlight %}
          <p>
            The <code>license.acknowledgements</code>, if provided, contains
            <i>all the attributions</i> this exercise makes for licensed
            use of other (separate) content. While the
            <code>license.attribution</code> contains content for the <i>users
            of this exercise</i> to include in derived works, the
            <code>license.acknowledgements</code> contains attributions
            acknowledging <i>other content this exercise uses</i>.
          </p>
          <p>
            Both the spelling "acknowledgments" (more common in the U.S.) and
            "acknowledgements" (more common in Britain and elsewhere) should
            be supported by tools (as synonyms).
          </p>
        </section>
        <section>
          <h4 id="license.permissions">license.permissions
            <small class="text-muted">recommended: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"permissions": { "enum": [
  "none",
  "read",
  "fork",
  "fork-with-tests",
  "contribute",
  "all"
] }
{% endhighlight %}
          <p>
            Although the license (as identified by the <code>license.id</code>
            governs the rights that other users have with this exercise, the
            <code>license.permissions</code> field provides a tool-processable
            shorthand notation to capture the access permissions granted to
            others by the license terms. The value should be one of:
          </p>
          <ul>
            <li><p><code>none</code>: "all rights reserved" (for the
              author(s)).</p></li>
            <li><p><code>read</code>: all other users can read/practice the
              exercise, use it in assignments, etc., but may not create any
            <li><p><code>fork</code>: In addition to <code>read</code>
              permissions, other users can "fork" this one--that is, use this
              exercise as a starting point to create a new derived exercise.
              Forking includes access to all aspects of the exercise except
              the test suites and the test environment definition. Users are
              expected to be aware of and obey any licensing restrictions
              imposed by the license associated with the original exercise.
            </p></li>
            <li><p><code>fork-with-tests</code>: Implies the same access
              permissions as <code>fork</code> but all test suites and test
              environment details are also included.</p></li>
            <li><p><code>contribute</code>: In addition to full
              <code>fork-with-tests</code> access, <code>contribute</code> adds
              the ability to edit and/or import updated versions of the original
              exercise.</p></li>
            <li><p><code>all</code>: Implies full access, which is the
              permissions level of the author(s) and/or license owner.</p></li>
          </ul>
        </section>
      </div>
    </div></div>

  </section>

</section>

<section>
  <h2 id="optional">Optional Keys</h2>

  <section>
    <h3 id="tag" data-toc-text="tag">tag
      <small class="text-muted">optional: object</small></h3>

    <p>
      The <code>tag</code> key maps to a nested dictionary (object) that
      defines categorical/classification/metadata about the exercise. The full
      definition of what is included under <code>tag</code> is described
      in the <a href="tagging.html">tagging definitions</a>.
    </p>
  </section>

  <section>
    <h3 id="src" data-toc-text="src">src
      <small class="text-muted">optional: object</small></h3>

    <p>
      The <code>src</code> key maps to a nested dictionary (object) that
      defines the source code assets associated with the exercise. The full
      definition of what is included under <code>src</code> is described
      in the <a href="code.html">code data model</a>.
    </p>
  </section>

  <section>
    <h3 id="suites" data-toc-text="suites">suites
      <small class="text-muted">recommended: object</small></h3>

    <p>
      The <code>suites</code> key maps to a nested dictionary (object) that
      defines the test suites associated with the exercise. The full
      definition of what is included under <code>suites</code> is described
      in the <a href="code.html">code data model</a>.
    </p>
  </section>

  <section>
    <h3 id="difficulty" data-toc-text="difficulty">difficulty
      <small class="text-muted">optional: string</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"difficulty": { "type": "integer", "minimum": 0, "maximum": 100 }
{% endhighlight %}

    <p>
      The <code>difficulty</code> is a subjective rating of question
      difficulty on an integer scale from 0 (easiest) to 100 (hardest).
      <strong>Difficulty is relative</strong> to the presumed level of
      the target audience intended for the exercise. Typically, an author
      might use <code>tags</code> to indicate the topics/skills that they
      expect the user to be familiar with, and also use <code>tags</code>
      to indicate the topics/skills that the intended audience would be
      <em>practicing</em> through this exercise. Together, the prerequisites
      and the topics for the exercise communicate the author's idea of the
      target audience, and difficulty should be interpreted relative to
      that target audience.
    </p>
    <p>
      Intuitively, the <code>difficulty</code> can be thought of as a rough
      approximation of <strong>the percentage of the target audience who
      might be unable to complete the exercise successfully</strong>. One
      would normally
      imagine that extreme values of 0 or 100 would not typically be used,
      since exercises no one can complete (difficulty == 100), or that
      everyone can trivially succeed at (difficulty == 0)) may have little
      value. Instead, a <code>difficulty</code> of 50 should be thought of
      as "average" difficulty, where an average student may have a 50/50
      chance of completing the exercise successfully.
    </p>
    <p>
      However, don't overthink it, since difficulty ratings are both
      subjective and relative. The author's intuitive reaction to the question
      of "how hard or easy is this exercise compared to an 'average' exercise
      for this target audience" is a better way to quickly assign a
      difficulty value that can still be of value to others reading the
      exercise description.
    </p>
    <p><span class="badge badge-primary">PEML example:</span></p>
{% highlight peml %}
difficulty: 60
{% endhighlight %}
  </section>

  <section>
    <h3 id="vendor" data-toc-text="vendor">vendor
      <small class="text-muted">optional: object</small></h3>

<p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"vendor": { "type": "object" }
{% endhighlight %}

    <p>
      The <code>vendor</code> key is intended to be a nested map containing
      any tool-specific keys or extension properties that individual
      educational tools might support, but that are not intended to be
      portable across a wide range of tools. The vocabulary and structure for
      the contents within this dictionary/map do not have any restrictions
      on how they are modeled.
    </p>
    <p>
      <span class="badge badge-warning">Note:</span>
      This is a great place to build out keys/properties that identify
      grading schemes, late policies, submission contraints, options for
      processing pipelines, etc. It would be nice if there were examples of
      tool-specific encodings of these kinds of details that might be
      used here.
    </p>
  </section>

</section>

<section>
  <h2 id="optional">Keys Under Development</h2>
  <p>
    The keys in this section are still under active development and are
    not fully defined or implemented. Consider them as ideas for future
    work.
  </p>

  <section>
    <h3 id="options" data-toc-text="options">options
      <small class="text-muted">optional: object</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"options": { "type": "object" }
{% endhighlight %}

    <p>
      The <code>options</code> key represents option settings that affect
      the interpretation of the PEML exercise description itself. These
      control things like what markup notation is used in text fields,
      whether mustache-style variable substitution is performed, support
      for random exercise generation, etc.
    </p>
    <div class="container-fluid"><div class="row">
      <div class="bracket col-1"></div>
      <div class="col-11">

        <section>
          <h4 id="options.text_format">options.text_format
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"text_format": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>options.text_format</code> ...
          </p>
        </section>
        <section>
          <h4 id="options.interpolation.enable">options.interpolation.enable
            <small class="text-muted">optional: boolean</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"enable": { "type": "boolean" }
{% endhighlight %}
          <p>
            The <code>options.interpolation.enable</code> ...
          </p>
        </section>
        <section>
          <h4 id="options.interpolation.delimiters">options.interpolation.delimiters
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"delimiters": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            The <code>options.interpolation.delimiters</code> ...
          </p>
        </section>
        <section>
          <h4 id="options.variables">options.variables
            <small class="text-muted">optional: object</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"variables": { "type": "object" }
{% endhighlight %}
          <p>
            The <code>options.variables</code> ...
          </p>
        </section>
        <section>
          <h4 id="options.generator">options.generator
            <small class="text-muted">optional: object</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"generator": { "type": "object" }
{% endhighlight %}
          <p>
            The <code>options.generator</code> ...
          </p>
        </section>
        <section>
          <h4 id="options.instances">options.instances
            <small class="text-muted">optional: array</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"instances": { "type": "array", "items": { "type": "object" }, "minItems": 1 }
{% endhighlight %}
          <p>
            The <code>options.instances</code> ...
          </p>
        </section>
      </div>
    </div></div>
  </section>

  <section>
    <h3 id="origin" data-toc-text="origin">origin
      <small class="text-muted">optional: object</small></h3>

    <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"origin": { "type": "object" }
{% endhighlight %}

    <p>
      The <code>origin</code> key is intended to be a nested map for
      exercises that are derived from (or forked from) others. It is
      intended to contain information about the original upstream
      exercise that was used as the starting point for this one.
    </p>

    <div class="container-fluid"><div class="row">
      <div class="bracket col-1"></div>
      <div class="col-11">
        <section>
          <h4 id="origin.derived_from">origin.derived_from
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"derived_from": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            Contains the <code>exercise_id</code> of the exercise this
            one was "forked" from, used when one exercise is created as
            a derived work based on another existing exercise.
          </p>
        </section>
        <section>
          <h4 id="origin.family">origin.family
            <small class="text-muted">optional: string</small></h4>

          <p><span class="badge badge-secondary">Schema:</span></p>
{% highlight json %}
"family": { "type": "string", "minLength": 1 }
{% endhighlight %}
          <p>
            One exercise might be created from another by changing the form
            of the question. For example, one exercise might be a code-writing
            exercise that asks "implement code that solves the following
            problem". From that, one might create a different style of
            exercise, such as "here's a buggy implementation for this problem,
            find and fix the bug". Or yet a third style of exercise: "what
            output does this code produce on the following input(s)?"
          </p>
          <p>
            At the same time, all these exercises are related in some way if
            the underlying task being performed by the artifact is the same,
            even if the skills the user is exercising are different. We can
            say these different styles of questions are all part of a related
            "family", where the relation is the underlying task being achieved
            by the code artifact at the heart of the question.
          </p>
          <p>
            Different styles of questions might commonly be created by forking
            an existing question and creating a derived version using a
            different style (code-writing, multiple-choice, output prediction,
            bug finding, bug fixing, etc.). The purpose of this key is
            to identify the family this exercise belongs to using some
            kind of unique identifier.
          </p>
          <p>
            <span class="badge badge-warning">Note:</span>
            We could use some nice ideas here about how to identify these.
          </p>
        </section>

      </div>
    </div></div>
  </section>

</section>
